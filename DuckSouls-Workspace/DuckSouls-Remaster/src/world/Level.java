package world;

import java.awt.Point;
import java.util.Random;

import entities.Enemy;
import entities.Player;
import tiles.Door;
import tiles.GeneralTile;
import utils.GameEvent;
import utils.GameEventQue;
import utils.Orientation;

/**
 * This class represents a level object in DuckSouls. A level contains a grid of
 * room objects, and allows the player to move between each room.
 */
public class Level {
	
	/*
	 * 
	 * STATIC VARIABLES
	 * 
	 */
	
	private static Random		_random					= new Random();
	
	/*
	 * 
	 * INSTANCE VARIABLES
	 * 
	 */
	
	private static final int	DEFAULT_LEVEL_SIZE		= 3;
	private static final int	DEFAULT_ROOM_SIZE		= 7;
	private static final int	DIFFICULTY_PER_LEVEL	= 5;
	
	private Room[][]			roomArray;
	
	public Room					currentRoom;
	private Point				currentRoomPoint;
	private Player				player;
	private int					levelWidth, levelHeight;
	private int					roomSize;
	private int					enemySpawnChance;
	private int					levelNum;
	
	/*
	 * 
	 * CONSTRUCTORS
	 * 
	 */
	
	/**
	 * Creates a level with a lot of the variables generated by the level. Used for
	 * creating a new level.
	 * 
	 * @param levelNum
	 *            The number of the level.
	 * @param player
	 *            The player object in the level.
	 * @param currentRoomPoint
	 *            The point defining what room in the room array to start in.
	 */
	public Level(int levelNum, Player player, Point currentRoomPoint) {
		
		this.levelWidth = DEFAULT_LEVEL_SIZE;
		this.levelHeight = DEFAULT_LEVEL_SIZE;
		this.roomSize = DEFAULT_ROOM_SIZE;
		
		this.levelNum = levelNum;
		this.enemySpawnChance = levelNum * DIFFICULTY_PER_LEVEL - DIFFICULTY_PER_LEVEL;
		
		this.genRoomArray();
		
		this.player = player;
		this.currentRoomPoint = currentRoomPoint;
		this.currentRoom = this.roomAt(this.currentRoomPoint);
		this.currentRoom.addEntity(this.player);
		
	}
	
	/**
	 * Creates a level with all variables inputed, not generated. This is used for
	 * generating room from save files.
	 * 
	 * @param roomArray
	 *            The array of room for the level.
	 * @param levelNum
	 *            The number of the level.
	 * @param player
	 *            The player object in the level.
	 * @param currentRoomPoint
	 *            The point defining what room in the room array to start in.
	 */
	public Level(Room[][] roomArray, int levelNum, Player player, Point currentRoomPoint) {
		
		this.levelWidth = roomArray.length;
		this.levelHeight = roomArray[0].length;
		
		this.levelNum = levelNum;
		
		this.roomArray = roomArray;
		
		this.player = player;
		this.currentRoomPoint = currentRoomPoint;
		this.currentRoom = this.roomAt(this.currentRoomPoint);
		this.currentRoom.addEntity(this.player);
		
	}
	
	/*
	 * 
	 * METHODS
	 * 
	 */
	
	/**
	 * Generates the room array and fills it with random rooms.
	 */
	private void genRoomArray() {
		
		this.roomArray = new Room[this.levelWidth][this.levelHeight];
		
		// For each room space...
		for (int y = 0; y < this.levelHeight; y++) {
			for (int x = 0; x < this.levelWidth; x++) {
				
				// Generate a square, random room
				this.roomArray[x][y] = new Room(this.roomSize, this.levelNum, this.enemySpawnChance);
				
			}
		}
		
		// Link all the rooms with doors
		this.placeAllConnectingDoors();
		
		// Randomly pick a room and tile for the stairs to be
		int stairsRoomX = _random.nextInt(levelWidth);
		int stairsRoomY = _random.nextInt(levelHeight);
		Room stairsRoom = this.roomArray[stairsRoomX][stairsRoomY];
		int stairsTileX = _random.nextInt(this.roomSize) + 1;
		int stairsTileY = _random.nextInt(this.roomSize) + 1;
		Point stairsPoint = new Point(stairsTileX, stairsTileY);
		
		// Place the stairs, and remove anything of top of them
		stairsRoom.setTile(stairsPoint, GeneralTile.STAIRS);
		stairsRoom.removeEnemy(stairsPoint);
		stairsRoom.removeItem(stairsPoint);
	}
	
	/**
	 * Places doors in the middle of each room-dividing wall in the room array.
	 */
	protected void placeAllConnectingDoors() {
		
		// Array container
		Point[] doors;
		
		// For each room...
		for (int y = 0; y < this.levelHeight; y++) {
			for (int x = 0; x < this.levelWidth; x++) {
				
				// Create an array with room for a point on each wall
				doors = new Point[4];
				
				/*
				 * For each wall... See if there is a room in that direction. If so, mark a
				 * point in the door array where a door should be. (Middle of the wall). Try /
				 * Catches are just to prevent errors from reaching out of the array for edge
				 * rooms
				 */
				
				try { // Check on the Top
					if (this.roomArray[x][y - 1] != null) {
						doors[0] = new Point((this.roomSize + 2) / 2, 0);
					}
				} catch (ArrayIndexOutOfBoundsException e) {
				}
				
				try { // Check on the Bottom
					if (this.roomArray[x][y + 1] != null) {
						doors[1] = new Point((this.roomSize + 2) / 2, (this.roomSize + 1));
					}
				} catch (ArrayIndexOutOfBoundsException e) {
				}
				
				try { // Check on the Left
					if (this.roomArray[x - 1][y] != null) {
						doors[2] = new Point(0, (this.roomSize + 2) / 2);
					}
				} catch (ArrayIndexOutOfBoundsException e) {
				}
				
				try { // Check on the Right
					if (this.roomArray[x + 1][y] != null) {
						doors[3] = new Point((this.roomSize + 1), (this.roomSize + 2) / 2);
					}
				} catch (ArrayIndexOutOfBoundsException e) {
				}
				
				// Place the doors in the room
				this.roomArray[x][y].placeDoors(doors);
				
			}
		}
		
	}
	
	/**
	 * Moves the player to a different room in the room array.
	 * 
	 * @param direction
	 *            The direction in the room array to move.
	 */
	public void moveRoom_Direction(Orientation direction) {
		
		Point newPlayerPoint = new Point(this.player.getPosition());
		
		// Remove the player from the old room
		this.currentRoom.removeEntity(this.player);
		
		this.currentRoomPoint = Orientation.pointAtDirection(this.currentRoomPoint, direction);
		this.currentRoom = roomAt(this.currentRoomPoint);
		
		// Depending on the direction, modify the position.
		switch (direction) {
			
			case NORTH:
				newPlayerPoint.y = this.currentRoom.getInternalHeight() + 1;
				break;
			
			case SOUTH:
				newPlayerPoint.y = 0;
				break;
			
			case EAST:
				newPlayerPoint.x = 0;
				break;
			
			case WEST:
				newPlayerPoint.x = this.currentRoom.getInternalWidth() + 1;
				break;
			
		}
		
		// Find a door in the next room on the appropriate wall to place the player on
		if (direction == Orientation.NORTH || direction == Orientation.SOUTH) { // NORTH / SOUTH
			
			for (int x = 1; x <= this.currentRoom.getInternalWidth(); x++) {
				
				Point pos = new Point(x, newPlayerPoint.y);
				
				if (this.currentRoom.tileAt(pos) instanceof Door) {
					newPlayerPoint = pos;
					break;
				}
				
			}
			
		} else {
			
			for (int y = 1; y <= this.currentRoom.getInternalHeight(); y++) { // EAST / WEST
				
				Point pos = new Point(newPlayerPoint.x, y);
				
				if (this.currentRoom.tileAt(pos) instanceof Door) {
					newPlayerPoint = pos;
					break;
				}
				
			}
			
		}
		
		// Place the player at the new position in the new room
		this.player.setPosition(newPlayerPoint);
		this.player.setOrientation(direction);
		this.currentRoom.addEntity(this.player);
		
	}
	
	/**
	 * Move the player in the level, and transfer the player between rooms when
	 * necessary.
	 * 
	 * @param direction
	 *            The direction to move the player.
	 */
	public void movePlayer(Orientation direction) {
		
		Point newPlayerPoint = Orientation.pointAtDirection(this.player.getPosition(), direction);
		this.player.setOrientation(direction);
		
		// Set the floor to a path if it's just a floor tile
		if (this.currentRoom.tileAt(this.player.getPosition()) == GeneralTile.FLOOR) {
			this.currentRoom.setTile(this.player.getPosition(), GeneralTile.PATH);
		}
		
		/*
		 * Check for a room move.
		 */
		
		boolean movedRooms = false;
		
		switch (direction) {
			
			case NORTH:
				if (newPlayerPoint.y == -1) {
					this.moveRoom_Direction(direction);
					movedRooms = true;
				}
				break;
			
			case SOUTH:
				if (newPlayerPoint.y == this.currentRoom.getInternalHeight() + 2) {
					this.moveRoom_Direction(direction);
					movedRooms = true;
				}
				break;
			
			case EAST:
				if (newPlayerPoint.x == this.currentRoom.getInternalWidth() + 2) {
					this.moveRoom_Direction(direction);
					movedRooms = true;
				}
				break;
			
			case WEST:
				if (newPlayerPoint.x == -1) {
					this.moveRoom_Direction(direction);
					movedRooms = true;
				}
				break;
			
		}
		
		/*
		 * Check conditions for the new point, and then set the player to the new
		 * position if applicable.
		 */
		
		if (movedRooms) {
			newPlayerPoint = player.getPosition();
		}
		
		if (this.currentRoom.tileAt(newPlayerPoint).getCanWalkOn()) {
			this.player.setPosition(newPlayerPoint);
		}
		
		// Pick up items
		if (this.currentRoom.itemAt(this.player.getPosition()) != null) {
			this.player.pickupItem(this.currentRoom.itemAt(this.player.getPosition()));
			this.currentRoom.removeItem(this.player.getPosition());
		}
		
		// Check for a battle
		for (Enemy enemy : this.currentRoom.getEnemyList()) {
			enemy.move(this.currentRoom, player.getPosition());
			if (enemy.getPosition().equals(this.player.getPosition())) {
				GameEventQue.addEvent(GameEvent.BATTLE);
			}
		}
		
		// Check for a level change
		if (this.currentRoom.tileAt(this.player.getPosition()) == GeneralTile.STAIRS) {
			GameEventQue.addEvent(GameEvent.LEVEL_CHANGE);
		}
		
	}
	
	/**
	 * Returns the room at a certain point in the room array.
	 * 
	 * @param position
	 *            The position of the room to get.
	 * @return The room at that position.
	 */
	public Room roomAt(Point position) {
		return this.roomArray[position.x][position.y];
	}
	
	/**
	 * Returns the point in the room array of the current room.
	 * 
	 * @return The point in the room array of the current room.
	 */
	public Point getCurrentRoomPoint() {
		return new Point(this.currentRoomPoint);
	}
	
	/**
	 * Returns the room array.
	 * 
	 * @return The room array.
	 */
	public Room[][] getRoomArray() {
		return this.roomArray;
	}
	
	/**
	 * Returns the level number.
	 * 
	 * @return The level number.
	 */
	public int getLevelNum() {
		return this.levelNum;
	}
	
}
